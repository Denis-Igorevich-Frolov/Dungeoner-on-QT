#ifndef MAGICDEFENSE_H
#define MAGICDEFENSE_H

#include "chunk.h"
#include "magicdefensebonus.h"

#include <QVector>

class MagicDefense
{
public:
    ~MagicDefense();

    int getValue() const;

    void addBonus(MagicDefenseBonus* bonus);
    bool removeBonus(MagicDefenseBonus* bonus);

    QVector<Chunk *> getChunks();

    void setNativeChunks(QVector<Chunk *> &newChunks);
    void setBonusChunks(const QVector<Chunk*> &newChunks);

    /*Обнуляет текущий активный чанк. Если обнуление было произведено, то водвращает true, если
     *нет то это означает, что весь прогрессбар уже полностью обнулён и возвращается false*/
    bool spendLastChunk();
    //Приравнивает значение текущего активного чанка к его максимальному значению
    void HealOneChunk();
    //Приравнивает значение всех чанков к их максимальному значению
    void HealAllChunk();

    /*Метод возвращает индекс текущего активного чанка. Текущим чанком
     *считается последний чанк, имеющий ненулевое значение.*/
    int getCurrentChunkIndex();
    /*Метод добавляет значение к текущему чанку. Если максимальное значение чанка не позволяет
     *переданному значению уместиться в нём полностью, то остаток переходит на следующий чанк,
     *и так пока либо не кончится значение, либо не кончатся чанки.*/
    void addValue(int value);
    /*Метод вычитает значение из текущего чанка. Если значение чанка меньше переданного вычитаемого
     *значения, то текущий чанк обнуляется, а остаток вычитается из предыдущего чанка, и так пока
     *либо не кончится значение, либо не кончатся чанки.*/
    void subtractValue(int value);

    int getTotalValue() const;

    int getAmountOfNativeChunks() const;

    int getAmountOfBonusChunks() const;


private:
    /*Добавление чанка в вектор бонусных чанков. В метод передаётся указатель на новый чанк, затем его
     *текущее значение обнуляется и указатель добавляется в конец вектора бонусных чанков. Новый чанк
     *будет иметь текущее значение 0, так как все бонусы дают прибавку только к максимальному значению,
     *а не к текущему.*/
    void addBonusChunk(Chunk* chunk);
    bool removeBonusChunk(Chunk* chunk);
    //Добавление одного чанка в вектор родных чанков
    void addChunk(Chunk* chunk);

    //Максимальное значение всего прогрессбара
    int totalValue = 0;
    //Текущее общее заполненное значение всех чанков прогрессбара
    int value = 0;

    int amountOfNativeChunks = 0;
    int amountOfBonusChunks = 0;

    //Перерасчёт общего вектора всех чанков, который включает в себя и родные и бонусные чанки
    void recalculationChunks();

    /*Метод устанавливает общее значение всему прогрессбару, последовательно заполняя все чанки пока
     *не кончится переданное значение. Используется для первичной инициализации и сохранения значения
     *при перерасчёте векторов прогрессбара из переменной value, чтобы оно не сбрасывалось при любом
     *изменении.*/
    void setValue(int newValue);

    void updateBonuses();

    QVector<Chunk*> chunks;
    //Вектор родных чанков, которые будут расположены в начале - перед бонусными
    QVector<Chunk*> nativeChunks;
    //Вектор бонусных чанков, который хранит все бонусы
    QVector<Chunk*> bonusChunks;
    //Вектор бонусных чанков, которые влезли в предел и будут добавлены в конец прогрессбара
    QVector<Chunk*> finalBonusChunks;

    //Вычисление текущего общего заполненного значения всех чанков прогрессбара
    void calculateValue();

    /*Очистка вектора родных чанков. Нужно быть осторожным в вызове этого метода, ведь он сам
     *не перерисовывает прогрессбар. После его вызова ОБЯЗАТЕЛЬНО должна быть переинициализация
     *вектора родных чанков, даже пустым вектором, если то нужно. Безопасен только вызов из
     *начала метода setChunks, потому что он сам и переинициализирует вектор родных чанков.*/
    void clearNativeChunks();

    QVector<MagicDefenseBonus*> bonuses;
};

#endif // MAGICDEFENSE_H
