/*******************************************************************************************
 *Данный класс является классом первичных статов. От него наследуются все другие классы.
 *******************************************************************************************/

#ifndef STAT_H
#define STAT_H

#include "Person/Stat/bonus.h"
#include "qobject.h"

#include <QVector>

class Stat: public QObject {
    Q_OBJECT
public:
    /*Разные группы статов имеют разные максимальные значения. Так для первичных навыков -
     *это 999999,а для вторичных - 9999999. Чтобы корректно работали ограничители на
     *сеттерах это максимальное значение задаётся при инициализации*/
    Stat(int maximum, QString personName, QString statName);
    /*Дополнительный конструктор с передоваемой ссылкой на вектор указателей на стат. При
     *использовании этого конструктора, полученный стат автоматически добавится в коллекцию.*/
    Stat(int maximum, QString personName, QString statName, QVector<Stat*>& stats);
    ~Stat();

    QString statName;

    int getValue() const;
    void setValue(int newValue);

    void addBonus(Bonus* bonus);

    /*Удаление бонуса. В метод передаётся указатель на бонус, который должен быть удалён. При этом
     *удаляется первый подошедший с конца бонус, а не конкретно тот, который инициировал удаление.
     *Если метод не смог обнаружить переданный на удаление бонус, он выводит предупреждение и
     *возвращает false, после чего следует запросить полный перерасчёт бонусов.*/
    virtual bool removeBonus(Bonus* bonus);

    int getFinalValue() const;

    QVector<Bonus *> getBonuses();

    /*Очистка вектора бонусов. Память указателей на бонусы не высвобождается,
     *так как это должно происходить только в классе предмета или эффекта*/
    virtual void removeAllBonuses();

    bool saveStat(bool saveValue, bool saveBonuses, bool createBackup);
    /*Так как для сохранения стата у разных наследников будет требоваться разное количество передоваемых
     *переменных, полиморфизма не получится. Чтобы решить эту проблему была создана функция быстрого
     *сохранения, которая не создаёт бекапа и сохраняет все возможные параметры стата.*/
    virtual bool fastSave();

    bool loadStat(bool loadValue, bool loadBonuses);
    /*Так как для загрузки стата у разных наследников будет требоваться разное количество
     *передоваемых переменных, полиморфизма не получится. Чтобы решить эту проблему была
     *создана функция быстрой загрузки, которая загружает все возможные параметры стата.*/
    virtual bool fastLoad();

    //Так как класс Stat унаследован от QObject, его оператор присваивания явным образом удалён, соответственно его следует переопределить самому
    Stat& operator= (const Stat &stat);
    int getMaximum() const;

signals:
    void statChanged(bool bonusChanged = true);

protected:
    //Создание бекапа сохранений в отдельной папке в той же директории, что и текущее сохранение
    void createBackup();

    int value = 0;
    //Значение с учётом всех бонусов
    int finalValue = 0;
    //Максимальное значение стата
    int maximum = 0;

    QVector<Bonus*> bonuses;

    //Вычисление финального максимального значения стата с учётом всех бонусов
    void calculateFinalValue();
    QString personName;
};

#endif // STAT_H
